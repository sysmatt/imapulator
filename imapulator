#!/usr/bin/env python3


import os, sys, logging, time, pprint, warnings, argparse, re, configparser, shutil, imaplib, email, email.header, email.utils, string
import pprint

warnings.filterwarnings('ignore')
ME = os.path.basename(sys.argv[0])
loggingFormat='%(asctime)s %(filename)s: %(message)s'
logging.basicConfig(stream=sys.stderr, level=logging.WARNING, format=loggingFormat)
logger = logging.getLogger(ME)
start_time = time.time()
configIni = {}
config = {}

parser = argparse.ArgumentParser()
parser.add_argument("-v", "--verbose",  help="increase output verbosity", action="store_true")
parser.add_argument("-d", "--debug",    help="enable debugging output", action="store_true")
parser.add_argument("-C", "--clear",    help="clear out pending messages upon startup before processing", action="store_true")
parser.add_argument("configFile",    help="provide a configuration file", action="store")
args = parser.parse_args()

# Holder of imap connection objects
imap = {}

if args.verbose:
    logger.setLevel(logging.INFO)
if args.debug:
    logger.setLevel(logging.DEBUG)


def bomb(chunk):
	logger.error("%s",chunk)
	sys.exit(1)

def imapConnect(thisAccount):
    global imap
    logger.debug("Opening [{}] IMAP to host [{}]".format(thisAccount, config[thisAccount]['HOST']))
    try:
        imap[thisAccount]  = imaplib.IMAP4_SSL(config[thisAccount]['HOST'])
    except Exception as error:
        bomb("Unable to connect to HOST [{}]".format(error))

    logger.debug("Authenticating [{}] IMAP to host [{}]".format(thisAccount, config[thisAccount]['HOST']))
    try:
        logger.debug("IMAP Login for USER [{}]".format(config[thisAccount].get('USER',thisAccount)))
        imap[thisAccount].login(config[thisAccount].get('USER',thisAccount), config[thisAccount]['PASS'])
    except Exception as error:
        bomb("Authentication error [{}]".format(error))


config = configparser.ConfigParser()

try:
    logger.debug("Reading configFile [{}]".format(args.configFile))
    config.read_file(open(args.configFile))
except Exception as error:
    bomb("Unable to read configFile [{}]".format(error))


def getCleanAddrHeader(msg,header):
    out = []
    for ht in email.utils.getaddresses(msg.get_all(header,[])):
        if ht:
            displayName,cleanAddr = ht
            logger.debug("ht[{}] displayName[{}] cleanAddr[{}]".format(ht,displayName,cleanAddr))
            out.append(cleanAddr)
    if out:
        logger.debug("getCleanAddrHeader header[{}] ret[{}]".format(header,",".join(out)))
        return(",".join(out))
    else:
        logger.debug("getCleanAddrHeader header[{}] empty".format(header))
        return("")

def emailDataSubst(emailData,templateIn):
    out=string.Template(templateIn).safe_substitute(emailData)
    logger.debug("templateIn[{}] out[{}]".format(templateIn,out))
    return(out)

for thisAccount in  (config.sections()):
    logger.debug("Opening initial connection for IMAP account [{}]".format(thisAccount))
    imapConnect(thisAccount)


for thisAccount in  (config.sections()):
    thisImap = imap[thisAccount]
    thisFolder = config[thisAccount].get('FOLDER','INBOX')
    try:
        logger.debug("Select folder [{}]".format(thisFolder))
        thisImap.select(thisFolder)
        rc, uidList = thisImap.uid('search',None,'ALL')
        msgQty = len(uidList[0].split())
        logger.debug("IMAP UID Search rc[{}] msgQty[{}]".format(rc,msgQty))
        for msgNum in range(msgQty):
            thisItemUid = uidList[0].split()[msgNum]
            rc, emailData = thisImap.uid('fetch', thisItemUid, '(RFC822)')
            logger.debug("IMAP UID Fetch rc[{}] msgNum[{}] thisItemUid[{}]".format(rc,msgNum,str(thisItemUid.decode('utf-8'))))
            emailRaw = emailData[0][1]
            emailMessage = email.message_from_string(emailRaw.decode('utf-8'))
            #logger.debug("emailMessage pprint={}".format(emailMessage))
            #logger.debug("dir emailMessage={}".format(dir(emailMessage)))
            #emailSubject, emailFrom, emailTo, emailCc = ['','','','']
            #if emailMessage['Subject']:
            #    emailSubject = email.header.decode_header(emailMessage['Subject'])[0][0]
            #if emailMessage['From']:
            #    emailFrom    = email.header.decode_header(emailMessage['From'])[0][0]
            #    t = email.utils.getaddresses(emailMessage.get_all('from',[]))
            #    logger.debug("From={}".format(pprint.pformat(emailMessage['From'])))
            #    logger.debug("util From={}".format(pprint.pformat(t)))
            #if emailMessage['To']:
            #    emailTo      = email.header.decode_header(emailMessage['To'])[0][0]
            #if emailMessage['Cc']:
            #    emailCc      = email.header.decode_header(emailMessage['Cc'])[0][0]
            # this will loop through all the available multiparts in mail
            emailData = {}
            emailData['BODY'] = ""
            for part in emailMessage.walk():
                if part.get_content_type() == "text/plain": # ignore attachments/html
                    body = str(part.get_payload(decode=True).decode('utf-8'))
                    logger.debug("Body [\n{}\n]".format(body))
                    emailData['BODY'] += body
                else:
                    continue
            # Assign all the data we will pass to actions
            emailData['TO']         = getCleanAddrHeader(emailMessage,"to")
            emailData['FROM']       = getCleanAddrHeader(emailMessage,"from")
            emailData['CC']         = getCleanAddrHeader(emailMessage,"cc")
            emailData['SUBJECT']    = emailMessage['subject']
            emailData['REPLYALL']   = emailData['FROM']
            if emailData['CC']:
                emailData['REPLYALL'] = ",".join([emailData['REPLYALL'],emailData['CC']])
            logger.debug(emailDataSubst(emailData,"emailDataSubst: TO[$TO] FROM[$FROM] CC[$CC] SUBJECT[$SUBJECT] REPLYALL[$REPLYALL] BODY[\n$BODY\n]"))
            #bomb("Testing")


    #except Exception as error:
    except AssertionError as error:
        bomb("Unable to select IMAP folder [{}] got error [{}]".format(thisFolder, error))


